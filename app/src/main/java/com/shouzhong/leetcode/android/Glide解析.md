# Glide

这个框架的目的是方便加载图片，android不像h5等没有自己的图片加载，因此只能自己实现或者借助第三方，其中Glide是很优秀的框架
之一，主要优点是写起来简单，扩展性强，生命周期管理，性能好。下面来分析下如何实现的

分析代码的最好方法就是通过使用顺序依次看源码都做了什么
一般我们是这样调用的Glide.with().as().apply().load().into()

首先我们来看with方法，这里传的参数是为了管理生命周期，返回的RequestManager看名字就知道这是个管理器，那么具体管理什么呢，
主要是生命周期的操作，然后就进入下一步：as()，返回RequestBuilder，这里需要把RequestManager传递过来，也就是这边需要
RequestManager里的内容，首先看apply方法，这个方法主要目的是处理加载好的图片（比如剪裁等），之后是load，这个方法就是
通过什么加载图片，记住，到现在开始还没有开始加载图片，都是准备工作，最后就是into了，里面主要的工作是生成Request，那么如何
生成呢，首先是获取之前设置的全部信息，先从复用池获取，没有生成一个新的，然后把这些信息设置进去，然后就是运行这个Request了，
我们看源码知道是调用了Request(SingleRequest)的begin方法，这里面最终通过Engine.load()方法去调用，那我们继续，Engine
设置了我们常说的三级缓存（内存，本地，网络），之后就是把任务放到线程池中

三级缓存其实和很简单的东西，首先我们要了解哪三级：内存、本地、网络，内存一般用Map去缓存，最重要的生成可以key，这里推荐用MD5链接的方式，
当然也可以Hash等算法，本地其实和内存差不多，只不过一个是临时存，一个是长期存，当然一搬也会设置一个有效时长，最后就是网络了，这个就没什么
好说的，一个技术的诞生总是因为需求，为什么会有三级缓存，主要还是为了更快的获取这个资源和重复获取资源造成的性能浪费，但是随着技术和网络的
不断升级，这个技术也会慢慢的消失

生命周期管理，这又是glide另一个值得称赞的地方，这个的主要作用就是在生命周期结束后终止未完成的任务，我们都知道，无论是本地还是网络加载图片
都是耗时操作，既然是耗时操作总会出现退出了但是任务还在进行的问题，造成不必要的性能浪费，甚至还会造成内存泄露，因此在退出后终止相关的任务是
必要的，所以首先要知道什么时候退出，早期版本是监听activity或者fragment的子fragment的生命周期，刚出那会还是很惊艳的，但是这个也有缺点，
新建fragment造成额外的开销，而且如果处理不好甚至造成内存泄露，后来google官方出了一个lifecycle，这个实现其实是给一个接口可以监听其生命
周期变换，没有新建fragment的操作，因此性能更好，其实这个实现也很简单，但是为什么glide不自己实现呢，答案是对使用glide的人来说将需要写额
外的代码，这不符合其设计理念：简单使用，所以早期用fragment去实现。

还是那句话，我们最终的目的是为了实现需求，而对使用的人来说尽量要简单（用户体验），当然这里面还有对性能，扩展性，实现复杂性等平衡。