# HashMap解析
首先从构造函数看，里面只进行两个参数的初始化，一个是初始扩容阈值系数，默认0.75，一个是初始阈值，为你传入值大于且最接近的2^n，默认16*0.75=9。

第一次调用put方法，先初始化容器，如果有传初始阈值，那么初始化后的容器的长度和阈值相同，没有的话，长度为16，阈值为16*扩容阈值系数，
然后就是数据插入，最主要的就是你插入位置，公式为:((容器长度 - 1) & key的hash值)，具体插入的值为Node（链表），存的值包括key，value，key的hash值，以及下一个位置。
这时候再来看第二次调用，假设我们用默认的参数，那么我们知道将不会进行扩容，同样计算插入位置，如果该位置没有值，那么和第一次插入过程一样，
如果该位置有值呢，如果key的hash值相同，且key相同（==或equals判断），那么直接替换这个的value值，如果不同，由于才第二次，所以直接加入链表。
好的，之后又进行了多次put的操作，这时遇到了一种新情况，就是插入的位置和某个链表的某个节点拥有相同的可以，那么只要替换这个节点的value就行了。
同样的操作，这时候又遇到了一种新情况，某个链表的长度过长（超过8），那么就会把链表转为红黑树，红黑树查找同二叉树。
这时候由于数据插入过多达到阈值，这时候会进行扩容的操作，容器长度变为原来2倍，阈值也变为原来的2倍，然后就是赋值的过程，单个值的直接按上面方式算出位置插入，
链表的话，每个拆出来，重新计算位置，组成新的链表（位置只能产生2个，一个是原来位置，一个是原来位置+原来长度），然后插入新的容器，
红黑树的话，类似链表，重新计算位置，组成新的红黑树（位置只能产生2个，一个是原来位置，一个是原来位置+原来长度），然后再根据红黑树的长度是否转为链表，再插入新的容器。

有了put的流程，再来看get就很简单了，也是像上面计算出位置，取出该位置节点，如果没有则返回null，如果有，且该节点不是链表或者红黑树，则直接取该节点的value值
如果是链表则遍历找到匹配的，或者找不到，如果是红黑树一样去寻找。

再来看remove的流程，首先是获得节点（最小的节点），链表，去掉链表的该节点，为红黑树，去掉红黑树的该节点，并根据红黑树长度决定是否转为链表

同类型的有
ConcurrentHashMap：默认设置了16个桶，每个桶可以看做一个Hashtable，根据需要锁住需要的桶保证线程安全，因此既保证了效率，又保证了线程安全  
Hashtable：绝对线程安全，因为所有的操作都加了同步锁，但是会导致效率低  
并不是说无脑用ConcurrentHashMap，要根据实际情况来定
