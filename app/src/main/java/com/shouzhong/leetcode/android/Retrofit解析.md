# Retrofit

Retrofit是对okhttp的封装，目的是为了让okhttp使用起来更简单，也就是一个网络框架，这里我们来分析Retrofit2

我们还是从使用入手然后去分析源码，我们会怎么使用呢，先创建一个接口，然后里面通过注解方法的方式来填写请求信息，这里我们其
实看不出什么，还是要看如何加载这个接口，加载方式为retrofit.create，我们点进去看create方法，发现用了代理的方式，所以
我们得先搞清楚代理是啥

代理模式是通过代理对象访问目标对象，这样可以在目标对象基础上增强额外的功能，如添加权限，访问控制和审计等功能。Proxy是jdk
实现的动态代理，主要作用是为了减少重复代码的书写，使用的时候主要用Proxy.newProxyInstance方法，然后实现InvocationHandler
接口做我们想做的事，里面invoke方法传递三个参数(Object proxy, Method method, Object[] args)，其中method就是调用
的方法，args是传进来的参数的值，这个设计的原意是为了在这个方法调用的前后做一些事，当然也可以不调用原方法。

回过头来我们再看，因为create只传了class进去，所以这边的代理相当于帮你实现接口的方法，然后怎么获取具体信息呢，还记得接口里面
的方法及参数都有注解吗，我们在代理中可以拿到method对象，那么就可以通过反射的方式获取方法和参数所携带的信息，竟然有了这些信息，
那么我们不是可以做自己想做的事了，这里做的事是网络请求。

Retrofit另一个特点就是可以addConverterFactory和addCallAdapterFactory，这里是采用集合去存这两个的，执行顺序后台添加
顺序一样。

说到Retrofit，我们也得分析下okhttp，还是从使用入手，一般先获取client，然后构造Request，然后调用client的newCall对象，
将Request对象转为Call对象，然后就可以用这个对象去网络请求了，call提供了同步和异步两个方法，这里只要看同步方法，因为异步
只是在这基础上帮你完成了线程间切换。点进去看发现核心方法是getResponseWithInterceptorChain，这里面用到了okhttp核心
之一拦截器，那么这些拦截器是怎么运作的呢，这里先说一个概念：责任链模式。在咱们的编程世界里，每一个环就等于一个节点、一个对象，
有各自负责的逻辑。当一个请求从链的首端发出，沿着链的路径依次传递给每一个节点，直到有节点处理这个请求为止，我们将这种模式称之
为责任链模式。看起来是不是像if else，没错，但是这里不用if else实现，而用集合的方式，为什么这样设计呢，主要为了解耦，其实这里
可以用链表的方式来实现，感觉更好。明白了这个你也就知道里面的拦截器大概是怎么运行了的。拦截器执行顺序和添加顺序一样。具体里面
做了什么事，这里就不分析了，按我们的话，都是业务代码，没啥说的。