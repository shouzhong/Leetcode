# 进程调度策略

## 普通回答
分为以下几种：
1. 先到先服务调度（FCFS）：不好的地方是让短进程等待长进程
2. 最短作业优先调度（SJF）：让短进程先执行，证明是最佳的，但是算法不好实现，因为很难预测下一个CPU执行的长度，算优先级调度的一种
3. 优先级调度
4. 转轮调度（RR）：分配q个时间单位，q是时间片，如果这个时间段内未结束，将被下一个进程抢占，并且排到就绪队列队尾，主要问题是时间片
的选择，太大会变成FCFS，太小上下文切换引起调度开销太大
5. 多级队列调度：允许多个不同算法用于不同类型进程，典型模型：前台使用RR，后台使用FCFS
6. 多级反馈队列调度：允许进程在队列之间迁移

## 延伸
对于支持线程的系统，操作系统调用的是内核级线程而非进程。  
用户级线程是由线程库管理的，而内核并不知道它们。用户级线程为了运行到cpu上，最终要映射到相关的内核级线程，但是这种映射肯不是直接的，
可能采用轻量级进程（LWP）。

### 多处理器调度
第一种，让一个处理器处理所有调度决定、I/O处理以及其他系统活动，其他处理器只执行用户代码。  
第二种是使用对称多处理（SMP），即每个处理器自我调度。所有进程可能处于一个共有的就绪队列，或者每个处理器都有自己的就绪队列。不管如何，
调度这样执行：每个处理器的调度程序都检查共同就绪队列，以便执行一个进程。大多数SMP试图让一个进程运行在同一个进程中，称为处理器的亲和性，
但是SMP系统最重要的是保持负载平衡，一般两种方法：推迁移和拉迁移，但是又会破坏处理器的亲和性

### Linux调度
完全公平调度程序（CFS）为默认调度方法。  
调度基于调度类，每个类都有一个特定的优先级。内核针对不同调度类采用不同调度方法。
标准内核实现了2个调度类：采用CFS调度算法的默认调度类和实时调度类。  
CFS 调度程序并不采用严格规则来为一个优先级分配某个长度的时间片，而是为每个任务分配一定比例的 CPU 处理时间。  
Linux CFS 调度程序采用高效算法，以便选择运行下个任务。每个可运行的任务放置在红黑树上。  
当一个任务变得可运行时，它被添加到树上。当一个任务变得不可运行时，它从树上删除。一般来说，得到较少处理时间的任务会偏向树的左侧；得到较
多处理时间的任务会偏向树的右侧。由于红黑树是平衡的，找到最左侧结点需要 lg N 的·时间复杂度。从 CFS 调度程序角度而言，这也是具有最高优先级的任务。

